#!/usr/bin/env bash

# shellcheck source=lib/common.sh
. "$LIB_DIR/common.sh"

# Deploy Values or Medians
tokens=$(jq -r ".tokens | keys_unsorted[]" "$CONFIG_FILE")
for token in $tokens; do
    pipAddr=$(jq -r ".tokens.${token} | .import.pip | values" "$CONFIG_FILE")
    if [[ "$pipAddr" == "" ]]; then
        type=$(jq -r ".tokens.${token} | .pipDeploy | .type | values" "$CONFIG_FILE")
        # Deploy Medianizer as Feed
        if [[ "$type" == "median" ]]; then
            contract=$(dappCreate testchain-medians "Median${token}USD")
            eval "export VAL_${token}=${contract}"
            log "VAL_${token}=$(eval "echo ${contract}")"
            signers=$(jq -r ".tokens.${token} | .pipDeploy | .signers | .[]" "$CONFIG_FILE")
            # Approve oracle price feed providers
            allsigners=()
            for signer in $signers; do
                allsigners+=("${signer#0x}")
            done
            sethSend "$(eval echo "\$VAL_${token}")" 'lift(address[] memory)' "[$(join "${allsigners[@]}")]"
            # Set quorum for Medianizer
            sethSend "$(eval echo "\$VAL_${token}")" 'setBar(uint256)' "$(seth --to-uint256 3)"
        fi
        # Deploy DSValue as Feed
        if [[ "${type}" == "value" ]]; then
            contract=$(dappCreate osm DSValue)
            eval "export VAL_${token}=${contract}"
            log "VAL_${token}=$(eval "echo ${contract}")"
        fi
    else
        eval "export VAL_${token}=${pipAddr}"
        copy osm
        copy testchain-medians
    fi
    eval "export PIP_${token}=\$VAL_${token}"
done

# Deploy Multicall
MULTICALL=$(dappCreate multicall Multicall)
log "MULTICALL=$MULTICALL"

# Deploy Token Faucet
FAUCET=$(jq -r ".import.faucet | values" "$CONFIG_FILE")
newFaucet=false
if [[ -z "$FAUCET" ]]; then
    FAUCET=$(dappCreate token-faucet RestrictedTokenFaucet)
    log "FAUCET=$FAUCET"
    newFaucet=true
    if [[ "$DEPLOY_RESTRICTED_FAUCET" == "no" ]]; then
        sethSend "$FAUCET" 'hope(address)' "0x0000000000000000000000000000000000000000"
    fi
fi

# Deploy ProxyRegistry
PROXY_REGISTRY=$(jq -r ".import.proxyRegistry | values" "$CONFIG_FILE")
if [[ -z "$PROXY_REGISTRY" ]]; then
    PROXY_FACTORY=$(dappCreate tss-proxy-actions DSProxyFactory)
    log "PROXY_FACTORY=$PROXY_FACTORY"
    PROXY_REGISTRY=$(dappCreate tss-proxy-actions ProxyRegistry "$PROXY_FACTORY")
    log "PROXY_REGISTRY=$PROXY_REGISTRY"
else
    PROXY_FACTORY=$(seth storage "$PROXY_REGISTRY" 1)
    PROXY_FACTORY=0x${PROXY_FACTORY:26:66}
fi

# Deploy Fabs
"$LIBEXEC_DIR/tss/deploy-fab"
# shellcheck source=/dev/null
. "$OUT_DIR/load-fabs-addr-temp"
rm "$OUT_DIR/load-fabs-addr-temp"

# Set the pause delay to 0 in order to make the needed initial configurations
export MCT_PAUSE_DELAY=0

# Make sure there is not $MCT_ADM set, so a temporary roles is created as authority (to handle variables set up easier)
unset MCT_ADM

MCT_GOV=$(jq -r ".import.gov | values" "$CONFIG_FILE")
if [[ -z "$MCT_GOV" ]]; then
    # It means the GOV token will be created now in the next deployment script call, then we can send funds to the Faucet and set permissions to FLOP
    newGovToken=true
else
    newGovToken=false
    export MCT_GOV
fi

MCT_ESM_MIN="$(seth --to-uint256 "$(seth --to-wei "$(jq -r ".esm_min | values" "$CONFIG_FILE")" "eth")")"
export MCT_ESM_MIN
MCT_ESM_PIT="$(jq -r ".esm_pit | values" "$CONFIG_FILE")"
export MCT_ESM_PIT

# Deploy MCT Core Contratcs
"$LIBEXEC_DIR/tss/deploy-core"
# shellcheck source=/dev/null
. "$OUT_DIR/load-core-addr-temp"
rm "$OUT_DIR/load-core-addr-temp"

# Mint Gov Token, send to the Faucet and set permissions if a new token
if [[ "$newGovToken" == true ]]; then
    sethSend "$MCT_GOV" 'mint(address,uint256)' "$FAUCET" "$(seth --to-uint256 "$(seth --to-wei 1000000 ETH)")"
    sethSend "$FAUCET" 'gulp(address)' "$MCT_GOV"

    # Use custom authority for the new GOV token
    GOV_GUARD=$(dappCreate mkr-authority MkrAuthority)
    log "GOV_GUARD=$GOV_GUARD"

    # Set GOV_GUARD as authority of MCT_GOV
    sethSend "$MCT_GOV" 'setAuthority(address)' "$GOV_GUARD"

    # Allow Flop to mint Gov token
    sethSend "$GOV_GUARD" 'rely(address)' "$MCT_FLOP"
fi

# Deploy Collaterals
for token in $tokens; do
    ilks=$(jq -r ".tokens.${token}.ilks | keys_unsorted[]" "$CONFIG_FILE")

    gemAddr=$(jq -r ".tokens.${token} | .import.gem | values" "$CONFIG_FILE")
    eval "export ${token}=${gemAddr}"

    for ilk in $ilks; do
        "$LIBEXEC_DIR/tss/deploy-ilk-$(echo "$token" | tr '[:upper:]' '[:lower:]')" "$ilk"
        # shellcheck source=/dev/null
        . "$OUT_DIR/load-ilk-addr-temp"
        rm "$OUT_DIR/load-ilk-addr-temp"

        # If the ilk token was created by the previous deployment script call (new token) and it is not ETH, then we can send funds to the Faucet
        if [[ "$token" != "ETH" && "$gemAddr" == "" ]]; then
            sethSend "$(eval echo "\$$token")" 'transfer(address,uint256)' "$FAUCET" "$(seth --to-uint256 "$(seth --to-wei 999000 ETH)")"
        fi
    done
done

if [[ "$newFaucet" == true ]]; then
    for token in $tokens; do
        sethSend "$FAUCET" 'setAmt(address,uint256)' "$(eval echo "\$${token}")" "$(seth --to-uint256 "$(seth --to-wei 50 ETH)")"
    done
fi

# Deploy Proxy Actions
PROXY_ACTIONS=$(dappCreate tss-proxy-actions-optimized TssProxyActions)
log "PROXY_ACTIONS=$PROXY_ACTIONS"
PROXY_ACTIONS_END=$(dappCreate tss-proxy-actions-optimized TssProxyActionsEnd)
log "PROXY_ACTIONS_END=$PROXY_ACTIONS_END"
PROXY_ACTIONS_DSR=$(dappCreate tss-proxy-actions-optimized TssProxyActionsDsr)
log "PROXY_ACTIONS_DSR=$PROXY_ACTIONS_DSR"

# Deploy CdpManager
CDP_MANAGER=$(dappCreate tss-proxy-actions TssCdpManager "$MCT_VAT")
log "CDP_MANAGER=$CDP_MANAGER"
GET_CDPS=$(dappCreate tss-proxy-actions GetCdps)
log "GET_CDPS=$GET_CDPS"

# Deploy OsmMom
OSM_MOM=$(dappCreate osm-mom OsmMom)
log "OSM_MOM=$OSM_MOM"

SAI_TUB=$(jq -r ".migration.tub | values" "$CONFIG_FILE")
ethAdapterAddr="$(eval echo "\$$(jq -r ".migration.ethAdapterVarName | values" "$CONFIG_FILE")")"
if [[ -n "$SAI_TUB" && -n "$ethAdapterAddr" ]]; then
    SAI_TUB=$(seth --to-checksum-address "$SAI_TUB")
    SAI="$(seth call "$SAI_TUB" 'sai()(address)')"
    export SAI
    PIP_SAI=$(dappCreate osm DSValue)
    log "PIP_SAI=$PIP_SAI"
    export PIP_SAI

    "$LIBEXEC_DIR/tss/deploy-ilk-sai"
    # shellcheck source=/dev/null
    . "$OUT_DIR/load-ilk-addr-temp"
    rm "$OUT_DIR/load-ilk-addr-temp"

    # Set SAI price = 1 USD
    sethSend "$PIP_SAI" 'poke(bytes32)' "$(seth --to-uint256 "$(seth --to-wei 1 ETH)")"

    # Set SAI pip authority to Proxy Pause
    sethSend "$PIP_SAI" 'setOwner(address)' "$MCT_PAUSE_PROXY"

    # Deploy SctMctMigration
    MIGRATION=$(dappCreate sct-mct-migration SctMctMigration "$SAI_TUB" "$CDP_MANAGER" "$MCT_JOIN_SAI" "$ethAdapterAddr" "$MCT_JOIN_TAO")
    log "MIGRATION=$MIGRATION"

    # Rely Migration contract to access the SAI Adapter
    sethSend "$MCT_JOIN_SAI" 'rely(address)' "$MIGRATION"
    # Rely Pause Proxy contract to access the SAI Adapter
    sethSend "$MCT_JOIN_SAI" 'rely(address)' "$MCT_PAUSE_PROXY"
    # Deny deployer to access the SAI Adapter
    sethSend "$MCT_JOIN_SAI" 'deny(address)' "$ETH_FROM"

    sethSend "$MCT_DEPLOY" 'releaseAuthFlip(bytes32)' "$(seth --to-bytes32 "$(seth --from-ascii "SAI")")"

    # Deploy MigrationProxyActions to use migrate function through DSProxy
    MIGRATION_PROXY_ACTIONS=$(dappCreate sct-mct-migration MigrationProxyActions)
    log "MIGRATION_PROXY_ACTIONS=$MIGRATION_PROXY_ACTIONS"
fi

# As all initial collaterals were deployed, we can remove authority of the deployment contract from the core contracts
sethSend "$MCT_DEPLOY" 'releaseAuth()'
for token in $tokens; do
    ilks=$(jq -r ".tokens.${token}.ilks | keys_unsorted[]" "$CONFIG_FILE")
    for ilk in $ilks; do
        # Rely Pause Proxy contract to access the Adapter
        sethSend "$(eval echo "\$MCT_JOIN_${token}_${ilk}")" 'rely(address)' "$MCT_PAUSE_PROXY"
        # Deny deployer to access the Adapter
        sethSend "$(eval echo "\$MCT_JOIN_${token}_${ilk}")" 'deny(address)' "$ETH_FROM"

        sethSend "$MCT_DEPLOY" 'releaseAuthFlip(bytes32)' "$(seth --to-bytes32 "$(seth --from-ascii "${token}-${ilk}")")"
    done
done

# Deploy GovActions - Library functions for the Pause
MCT_GOV_ACTIONS=$(dappCreate tss-deploy GovActions)
log "MCT_GOV_ACTIONS=$MCT_GOV_ACTIONS"

# Deploy Pause Proxy Actions (support contract for executing initial set up of the tss system)
PROXY_PAUSE_ACTIONS=$(dappCreate tss-deploy-pause-proxy-actions TssDeployPauseProxyActions)
log "PROXY_PAUSE_ACTIONS=$PROXY_PAUSE_ACTIONS"

# Get a proxy for the deployer address (create if didn't previously exist)
PROXY_DEPLOYER=$(seth call "$PROXY_REGISTRY" 'proxies(address)(address)' "$ETH_FROM")
if [[ "$PROXY_DEPLOYER" == "0x0000000000000000000000000000000000000000" ]]; then
    sethSend "$PROXY_REGISTRY" 'build()'
    PROXY_DEPLOYER="$(seth call "$PROXY_REGISTRY" 'proxies(address)(address)' "$ETH_FROM")"
    log "PROXY_DEPLOYER=$PROXY_DEPLOYER"
fi

# Set the proxy address as root of the roles (in order to be able to do all the variables set up)
sethSend "$MCT_ADM" 'setRootUser(address,bool)' "$PROXY_DEPLOYER" true

# Deploy chief as new $MCT_ADM if there isn't an authority in the config file
MCT_ADM=$(jq -r ".import.authority | values" "$CONFIG_FILE")
if [[ -z "$MCT_ADM" ]]; then
    MCT_IOU=$(dappCreate vote-proxy DSToken "$(seth --to-bytes32 "$(seth --from-ascii "IOU")")")
    log "MCT_IOU=$MCT_IOU"

    MCT_ADM=$(dappCreate vote-proxy DSChief "$MCT_GOV" "$MCT_IOU" 5)
    log "MCT_ADM=$MCT_ADM"
    sethSend "$MCT_IOU" 'setOwner(address)' "${MCT_ADM}"

    # Deploy Vote Proxy Factory
    VOTE_PROXY_FACTORY=$(dappCreate vote-proxy VoteProxyFactory "$MCT_ADM")
    log "VOTE_PROXY_FACTORY=$VOTE_PROXY_FACTORY"
else
    copy vote-proxy
fi

if [[ -n "$GOV_GUARD" ]]; then
    sethSend "$GOV_GUARD" 'setRoot(address)' "$MCT_PAUSE_PROXY"
fi

for token in $tokens; do
    ILKS_VARS+=",
    \"${token}\": \"$(seth --to-checksum-address "$(eval echo "\$${token}")")\""
    if [[ "$(eval echo "\$VAL_${token}")" != "" ]]; then
    ILKS_VARS+=",
    \"VAL_${token}\": \"$(seth --to-checksum-address "$(eval echo "\$VAL_${token}")")\""
    fi
    ILKS_VARS+=",
    \"PIP_${token}\": \"$(seth --to-checksum-address "$(eval echo "\$PIP_${token}")")\""
    ilks=$(jq -r ".tokens.${token}.ilks | keys_unsorted[]" "$CONFIG_FILE")
    for ilk in $ilks; do
    ILKS_VARS+=",
    \"MCT_JOIN_${token}_${ilk}\": \"$(eval echo "\$MCT_JOIN_${token}_${ilk}")\""
    ILKS_VARS+=",
    \"MCT_FLIP_${token}_${ilk}\": \"$(seth --to-checksum-address "$(eval echo "\$MCT_FLIP_${token}_${ilk}")")\""
    done
done

if [[ -n "$MIGRATION" ]]; then
    ILKS_VARS+=",
    \"SAI\": \"$(seth --to-checksum-address "$SAI")\""
    ILKS_VARS+=",
    \"PIP_SAI\": \"$PIP_SAI\""
    ILKS_VARS+=",
    \"MCT_JOIN_SAI\": \"$MCT_JOIN_SAI\""
    ILKS_VARS+=",
    \"MCT_FLIP_SAI\": \"$T(seth --to-checksum-address "$MCT_FLIP_SAI")\""

    MIGRATION_VARS=",
    \"SAI_TUB\": \"$SAI_TUB\""
    MIGRATION_VARS+=",
    \"MIGRATION\": \"$MIGRATION\""
    MIGRATION_VARS+=",
    \"MIGRATION_PROXY_ACTIONS\": \"$MIGRATION_PROXY_ACTIONS\""
fi

if [[ -n $GOV_GUARD ]]; then
    GOV_GUARD_VAR=",
    \"GOV_GUARD\": \"$GOV_GUARD\""
fi
if [[ -n $MCT_IOU ]]; then
    MCT_IOU_VAR=",
    \"MCT_IOU\": \"$MCT_IOU\""
fi
if [[ -n $VOTE_PROXY_FACTORY ]]; then
    VOTE_PROXY_FACTORY_VAR=",
    \"VOTE_PROXY_FACTORY\": \"$VOTE_PROXY_FACTORY\""
fi

# Generate addresses.json file
cat > "$OUT_DIR"/addresses.json <<EOF
{
    "DEPLOYER": "$(seth --to-checksum-address "$ETH_FROM")",
    "MULTICALL": "$MULTICALL",
    "FAUCET": "$(seth --to-checksum-address "$FAUCET")",
    "MCT_DEPLOY": "$MCT_DEPLOY",
    "MCT_GOV": "$(seth --to-checksum-address "$MCT_GOV")"$GOV_GUARD_VAR$MCT_IOU_VAR,
    "MCT_ADM": "$(seth --to-checksum-address "$MCT_ADM")"$VOTE_PROXY_FACTORY_VAR,
    "MCT_VAT": "$(seth --to-checksum-address "$MCT_VAT")",
    "MCT_JUG": "$(seth --to-checksum-address "$MCT_JUG")",
    "MCT_CAT": "$(seth --to-checksum-address "$MCT_CAT")",
    "MCT_VOW": "$(seth --to-checksum-address "$MCT_VOW")",
    "MCT_JOIN_TAO": "$(seth --to-checksum-address "$MCT_JOIN_TAO")",
    "MCT_FLAP": "$(seth --to-checksum-address "$MCT_FLAP")",
    "MCT_FLOP": "$(seth --to-checksum-address "$MCT_FLOP")",
    "MCT_PAUSE": "$(seth --to-checksum-address "$MCT_PAUSE")",
    "MCT_PAUSE_PROXY": "$(seth --to-checksum-address "$MCT_PAUSE_PROXY")",
    "MCT_GOV_ACTIONS": "$MCT_GOV_ACTIONS",
    "MCT_TAO": "$(seth --to-checksum-address "$MCT_TAO")",
    "MCT_SPOT": "$(seth --to-checksum-address "$MCT_SPOT")",
    "MCT_POT": "$(seth --to-checksum-address "$MCT_POT")",
    "MCT_END": "$(seth --to-checksum-address "$MCT_END")",
    "MCT_ESM": "$(seth --to-checksum-address "$MCT_ESM")",
    "PROXY_ACTIONS": "$PROXY_ACTIONS",
    "PROXY_ACTIONS_END": "$PROXY_ACTIONS_END",
    "PROXY_ACTIONS_DSR": "$PROXY_ACTIONS_DSR",
    "CDP_MANAGER": "$CDP_MANAGER",
    "GET_CDPS": "$GET_CDPS",
    "OSM_MOM": "$OSM_MOM",
    "PROXY_FACTORY": "$(seth --to-checksum-address "$PROXY_FACTORY")",
    "PROXY_REGISTRY": "$(seth --to-checksum-address "$PROXY_REGISTRY")"$ILKS_VARS,
    "PROXY_PAUSE_ACTIONS": "$PROXY_PAUSE_ACTIONS",
    "PROXY_DEPLOYER": "$(seth --to-checksum-address "$PROXY_DEPLOYER")"$MIGRATION_VARS
}
EOF

"$LIBEXEC_DIR"/setters/set-vat-line

"$LIBEXEC_DIR"/setters/set-vow-wait

"$LIBEXEC_DIR"/setters/set-vow-bump

"$LIBEXEC_DIR"/setters/set-vow-dump

"$LIBEXEC_DIR"/setters/set-vow-sump

"$LIBEXEC_DIR"/setters/set-vow-hump

"$LIBEXEC_DIR"/setters/set-jug-base

"$LIBEXEC_DIR"/setters/set-pot-dsr

"$LIBEXEC_DIR"/setters/set-end-wait

"$LIBEXEC_DIR"/setters/set-beg "flap"

"$LIBEXEC_DIR"/setters/set-ttl "flap"

"$LIBEXEC_DIR"/setters/set-tau "flap"

"$LIBEXEC_DIR"/setters/set-beg "flop"

"$LIBEXEC_DIR"/setters/set-flop-pad

"$LIBEXEC_DIR"/setters/set-ttl "flop"

"$LIBEXEC_DIR"/setters/set-tau "flop"

"$LIBEXEC_DIR"/setters/set-ilks-price

"$LIBEXEC_DIR"/setters/set-ilks-pip-whitelist

"$LIBEXEC_DIR"/setters/set-ilks-mat

"$LIBEXEC_DIR"/setters/set-ilks-line

"$LIBEXEC_DIR"/setters/set-ilks-dust

"$LIBEXEC_DIR"/setters/set-ilks-duty

"$LIBEXEC_DIR"/setters/set-ilks-spotter-poke

"$LIBEXEC_DIR"/setters/set-ilks-chop

"$LIBEXEC_DIR"/setters/set-ilks-lump

"$LIBEXEC_DIR"/setters/set-ilks-beg

"$LIBEXEC_DIR"/setters/set-ilks-ttl

"$LIBEXEC_DIR"/setters/set-ilks-tau

if [[ -f "$CASE" ]]; then
    "$CASE"
fi

"$LIBEXEC_DIR"/setters/set-ilks-osm

"$LIBEXEC_DIR"/setters/set-ilks-osm-mom

"$LIBEXEC_DIR"/setters/set-pause-auth-delay
